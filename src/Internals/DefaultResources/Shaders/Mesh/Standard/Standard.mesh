#extension GL_EXT_mesh_shader : enable

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 64, max_primitives = 126) out;


layout(location = 0) out MS_V_OUT {
	vec3 FragPos;
	vec3 Normal;
	vec3 Tangent;
	vec2 TexCoord;
} ms_v_out[];

void main()
{
	uint renderTaskIndex = 
		gl_WorkGroupID.x
		+ gl_WorkGroupID.y * gl_NumWorkGroups.x
		+ gl_WorkGroupID.z * gl_NumWorkGroups.x * gl_NumWorkGroups.y;
	uint meshletIndex = EE_RENDER_TASKS[renderTaskIndex].meshletIndex;
	uint instanceIndex = EE_RENDER_TASKS[renderTaskIndex].instanceIndex;
	mat4 model = EE_INSTANCES[instanceIndex].model;
	uint verticesSize = EE_MESHLETS[meshletIndex].verticesSize;
	for (uint i = 0; i < verticesSize; ++i)
	{
		uint vertexIndex = EE_MESHLETS[meshletIndex].vertexIndices[i];
		vec3 N = normalize(vec3(model * vec4(EE_VERTICES[vertexIndex].normal.xyz, 0.0)));
		vec3 T = normalize(vec3(model * vec4(EE_VERTICES[vertexIndex].tangent.xyz, 0.0)));
		// re-orthogonalize T with respect to N
		T = normalize(T - dot(T, N) * N);
		ms_v_out[i].FragPos =	vec3(model * vec4(EE_VERTICES[vertexIndex].position.xyz, 1.0));
		ms_v_out[i].Normal = N;
		ms_v_out[i].Tangent = T;
		ms_v_out[i].TexCoord = EE_VERTICES[vertexIndex].texCoord.xy;
		gl_MeshVerticesEXT[i].gl_Position = EE_CAMERAS[EE_CAMERA_INDEX].EE_CAMERA_PROJECTION_VIEW * vec4(ms_v_out[i].FragPos, 1.0);
	}

	uint triangleSize = EE_MESHLETS[meshletIndex].triangleSize;
	SetMeshOutputsEXT(verticesSize, triangleSize);

	for (uint i = 0; i < triangleSize; ++i)
	{
		gl_PrimitiveTriangleIndicesEXT[i] = 
			uvec3(
				EE_MESHLETS[meshletIndex].primitiveIndices[i * 3],
				EE_MESHLETS[meshletIndex].primitiveIndices[i * 3 + 1],
				EE_MESHLETS[meshletIndex].primitiveIndices[i * 3 + 2]);

	}
}
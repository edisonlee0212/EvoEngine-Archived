#extension GL_NV_mesh_shader : require

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 64, max_primeshletIndextives = 126) out;


layout(location = 0) out VS_OUT {
	vec3 FragPos;
	vec3 Normal;
	vec3 Tangent;
	vec2 TexCoord;
} vs_out[];

void main()
{
	uint meshletIndex = 
		gl_WorkGroupID.x
		+ gl_WorkGroupID.y * gl_NumWorkGroups.x
		+ gl_WorkGroupID.z * gl_NumWorkGroups.x * gl_NumWorkGroups.y;

	mat4 model = EE_INSTANCES[EE_INSTANCE_INDEX].model;
	uint verticesSize = EE_MESHLETS[meshletIndex].vertexIndicesSize;
	for (uint i = 0; i < verticesSize; ++i)
	{
		uint vertexIndex = EE_MESHLETS[meshletIndex].vertexIndices[i];
		vec3 N = normalize(vec3(model * vec4(EE_VERTICES[vertexIndex].normal, 0.0)));
		vec3 T = normalize(vec3(model * vec4(EE_VERTICES[vertexIndex].tangent, 0.0)));
		// re-orthogonalize T with respect to N
		T = normalize(T - dot(T, N) * N);
		vs_out[i].FragPos =	vec3(model * vec4(EE_VERTICES[vertexIndex].position, 1.0));
		vs_out[i].Normal = N;
		vs_out[i].Tangent = T;
		vs_out[i].TexCoord = EE_VERTICES[vertexIndex].texCoord;
		gl_MeshVerticesEXT[i].gl_Position = EE_CAMERAS[EE_CAMERA_INDEX].EE_CAMERA_PROJECTION_VIEW * vec4(vs_out[i].FragPos, 1.0);
	}

	uint triangleSize = EE_MESHLETS[meshletIndex].triangleSize;
	gl_PrimeshletIndextiveCountEXT = triangleSize;

	for (uint i = 0; i < triangleSize; ++i)
	{
		gl_PrimitiveTriangleIndicesEXT[i] = 
			uint3(
				EE_MESHLETS[meshletIndex].primeshletIndextiveIndices[i * 3],
				EE_MESHLETS[meshletIndex].primeshletIndextiveIndices[i * 3 + 1],
				EE_MESHLETS[meshletIndex].primeshletIndextiveIndices[i * 3 + 2]);
	}
}